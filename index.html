<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Draggable Squares with Smooth Snap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <style>
    body {
      background-color: #7FFFD4;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    .square {
      width: 260px;
      height: 260px;
      background-color: #FFFF00;
      position: absolute;
      cursor: grab;
      user-select: none;
      box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
      transition: transform 0.1s ease; /* 드래그 중 회전 효과용 */
    }
  </style>
</head>
<body>
  <script>
    // 헬퍼: 요소의 위치(rectangle) 정보를 반환
    function getRect(element) {
      return element.getBoundingClientRect();
    }
    
    // gap만큼 확장된 영역을 고려해 충돌 여부를 판단
    function isColliding(elem1, elem2, gap) {
      const rect1 = getRect(elem1);
      const rect2 = getRect(elem2);
      const extended = {
        left: rect2.left - gap,
        right: rect2.right + gap,
        top: rect2.top - gap,
        bottom: rect2.bottom + gap
      };
      return !(rect1.right < extended.left ||
               rect1.left > extended.right ||
               rect1.bottom < extended.top ||
               rect1.top > extended.bottom);
    }
    
    const numSquares = 5;
    const squares = [];
    const gap = 30; // 최소 간격 30픽셀

    // 무작위 위치 생성 (정사각형 크기 260x260 고려)
    function getRandomPosition() {
      const maxX = window.innerWidth - 260;
      const maxY = window.innerHeight - 260;
      return {
        x: Math.floor(Math.random() * maxX),
        y: Math.floor(Math.random() * maxY)
      };
    }

    // 해당 정사각형이 주어진 (x,y) 위치에서 다른 정사각형과 gap 이상 떨어져 있는지 확인
    function isValidPosition(square, x, y, gap) {
      square.style.left = x + 'px';
      square.style.top = y + 'px';
      for (const other of squares) {
        if (other === square) continue;
        if (isColliding(square, other, gap)) {
          return false;
        }
      }
      return true;
    }

    // 정사각형 생성 (겹치지 않고 최소 30픽셀 간격 유지)
    for (let i = 0; i < numSquares; i++) {
      const square = document.createElement('div');
      square.classList.add('square');
      let pos;
      let attempts = 0;
      do {
        pos = getRandomPosition();
        attempts++;
        if (attempts > 100) break;
      } while (!isValidPosition(square, pos.x, pos.y, gap));
      square.style.left = pos.x + 'px';
      square.style.top = pos.y + 'px';
      document.body.appendChild(square);
      squares.push(square);
    }
    
    // 드래그 및 회전 효과 관련 변수
    let currentSquare = null;
    let offsetX = 0;
    let offsetY = 0;
    let lastX = 0;
    const maxAngle = 10;         // 최대 회전 각도 (deg)
    const rotationFactor = 0.5;  // 마우스 수평 이동에 따른 회전 계수

    // 마우스 이벤트 핸들러
    function onMouseDown(e) {
      if (e.target.classList.contains('square')) {
        currentSquare = e.target;
        offsetX = e.clientX - currentSquare.offsetLeft;
        offsetY = e.clientY - currentSquare.offsetTop;
        lastX = e.clientX;
        currentSquare.style.cursor = 'grabbing';
      }
    }
    
    function onMouseMove(e) {
      if (currentSquare) {
        const newLeft = e.clientX - offsetX;
        const newTop = e.clientY - offsetY;
        currentSquare.style.left = newLeft + 'px';
        currentSquare.style.top = newTop + 'px';
        
        // 수평 이동량(dx)에 따른 회전 효과 (드래그 방향 반응)
        const dx = e.clientX - lastX;
        lastX = e.clientX;
        let angle = dx * rotationFactor;
        angle = Math.max(-maxAngle, Math.min(maxAngle, angle));
        currentSquare.style.transform = `rotate(${angle}deg)`;
      }
    }
    
    // 부드러운 스냅 기능: 드래그 종료 시, 주변과의 간격이 gap 미만이면 부드럽게 재배치
    function snapSquare(square) {
      let rect = getRect(square);
      let targetLeft = parseInt(square.style.left, 10);
      let targetTop = parseInt(square.style.top, 10);
      let collisionFound = false;
      
      // 다른 모든 정사각형과의 간격 검사
      for (const other of squares) {
        if (other === square) continue;
        if (isColliding(square, other, gap)) {
          collisionFound = true;
          const otherRect = getRect(other);
          // 후보 위치 계산: 다른 사각형의 오른쪽, 왼쪽, 아래쪽, 위쪽에 gap을 두고 배치
          const candidateRight = otherRect.right + gap;
          const candidateLeft  = otherRect.left - rect.width - gap;
          const candidateBottom = otherRect.bottom + gap;
          const candidateTop = otherRect.top - rect.height - gap;
          
          // 현재 정사각형과의 수평, 수직 거리 차이를 계산
          const deltaRight = Math.abs(candidateRight - rect.left);
          const deltaLeft = Math.abs(candidateLeft - rect.left);
          const deltaBottom = Math.abs(candidateBottom - rect.top);
          const deltaTop = Math.abs(candidateTop - rect.top);
          
          // 가장 작은 조정량을 선택하여 스냅
          const minDelta = Math.min(deltaRight, deltaLeft, deltaBottom, deltaTop);
          if (minDelta === deltaRight) {
            targetLeft = candidateRight;
          } else if (minDelta === deltaLeft) {
            targetLeft = candidateLeft;
          } else if (minDelta === deltaBottom) {
            targetTop = candidateBottom;
          } else if (minDelta === deltaTop) {
            targetTop = candidateTop;
          }
          // 한 번의 충돌 처리 후 break (여러 충돌 처리도 가능하나 여기서는 단순 처리)
          break;
        }
      }
      
      if (collisionFound) {
        square.style.transition = "left 0.5s ease, top 0.5s ease";
        square.style.left = targetLeft + "px";
        square.style.top = targetTop + "px";
        square.addEventListener('transitionend', function handler() {
          square.style.transition = "";
          square.removeEventListener('transitionend', handler);
        });
      }
    }
    
    function onMouseUp() {
      if (currentSquare) {
        currentSquare.style.cursor = 'grab';
        // 드래그 종료 시 회전 효과 초기화
        currentSquare.style.transform = 'rotate(0deg)';
        // 스냅 기능 적용: 주변 정사각형과의 gap이 부족하면 부드럽게 이동
        snapSquare(currentSquare);
        currentSquare = null;
      }
    }
    
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  </script>
</body>
</html>